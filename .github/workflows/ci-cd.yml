name: CI/CD Pipeline - AutoMax Car Dealership

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: automax-dealership
  ECS_SERVICE: automax-service
  ECS_CLUSTER: automax-cluster
  ECS_TASK_DEFINITION: automax-task-definition

jobs:
  # Job 1: Code Quality and Testing
  test:
    name: ğŸ§ª Test & Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: ğŸ“¦ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest requests

    - name: ğŸ” Lint HTML Files
      run: |
        # Install HTML linter
        npm install -g htmlhint
        htmlhint index.html

    - name: ğŸ¨ Lint CSS Files
      run: |
        # Install CSS linter
        npm install -g stylelint stylelint-config-standard
        echo '{"extends": "stylelint-config-standard"}' > .stylelintrc.json
        stylelint "*.css" || true  # Allow to continue even with warnings

    - name: âš¡ Lint JavaScript Files
      run: |
        # Install JS linter
        npm install -g eslint
        npx eslint --init --yes || true
        npx eslint "*.js" || true  # Allow to continue even with warnings

    - name: ğŸ§ª Run Website Tests
      run: |
        # Start a simple HTTP server for testing
        python -m http.server 8000 &
        sleep 5
        
        # Run Python tests
        export TEST_URL="http://localhost:8000"
        python -m pytest tests/ -v --tb=short

    - name: ğŸ“Š Generate Test Report
      if: always()
      run: |
        echo "Test execution completed"
        echo "Timestamp: $(date)"

  # Job 2: Build and Push Docker Image
  build:
    name: ğŸ³ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ”‘ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ğŸ·ï¸ Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ğŸ› ï¸ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ³ Build and Push Docker Image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ğŸ” Scan Image for Vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        exit-code: '0'  # Don't fail the build on vulnerabilities
        severity: 'CRITICAL,HIGH,MEDIUM'
      continue-on-error: true

    - name: ğŸ“‹ Upload Trivy Scan Results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('trivy-results.sarif') != ''
      with:
        sarif_file: 'trivy-results.sarif'
        category: 'trivy-container-scan'
      continue-on-error: true

    - name: ğŸ” Alternative Security Scan (Local Image)
      if: always()
      run: |
        echo "ğŸ”’ Running security scan on locally built image..."
        
        # Use the local image that was just built (no ECR pull needed)
        LOCAL_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest"
        
        # Check if the local image exists
        if docker image inspect "$LOCAL_IMAGE" >/dev/null 2>&1; then
          echo "âœ… Scanning local image: $LOCAL_IMAGE"
          # Run Trivy scan on local image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --format table \
            --severity HIGH,CRITICAL \
            "$LOCAL_IMAGE" || true
        else
          echo "âš ï¸ Local image not found, scanning base nginx:alpine instead"
          # Fallback to scanning base image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --format table \
            --severity HIGH,CRITICAL \
            nginx:alpine || true
        fi
        
        echo "âœ… Security scan completed"

    - name: ğŸ“Š Generate Security Report Summary
      if: always()
      run: |
        echo "## ğŸ”’ Security Scan Summary" >> $GITHUB_STEP_SUMMARY
        echo "- Image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest" >> $GITHUB_STEP_SUMMARY
        echo "- Scan Date: $(date)" >> $GITHUB_STEP_SUMMARY
        if [ -f "trivy-results.sarif" ]; then
          echo "- âœ… SARIF results generated for GitHub Security tab" >> $GITHUB_STEP_SUMMARY
        else
          echo "- âš ï¸ SARIF upload skipped (check repository permissions)" >> $GITHUB_STEP_SUMMARY
        fi
        echo "- ğŸ“Š Table format scan completed (see logs above)" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy Infrastructure with Terraform
  deploy-infrastructure:
    name: ğŸš€ Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/main'
    
    defaults:
      run:
        working-directory: terraform

    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: âš™ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: ğŸ”§ Terraform Init
      run: terraform init

    - name: ğŸ“‹ Terraform Plan
      run: |
        terraform plan \
          -var="image_uri=${{ needs.build.outputs.image-tag }}" \
          -var="environment=production" \
          -out=tfplan

    - name: ğŸš€ Terraform Apply
      run: terraform apply -auto-approve tfplan

    - name: ğŸ“¤ Output Infrastructure Info
      run: |
        echo "Load Balancer DNS: $(terraform output -raw load_balancer_dns)"
        echo "ECS Cluster: $(terraform output -raw ecs_cluster_name)"

  # Job 4: Deploy Application to ECS
  deploy-application:
    name: ğŸ¯ Deploy Application
    runs-on: ubuntu-latest
    needs: [build, deploy-infrastructure]
    if: github.ref == 'refs/heads/main'

    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ“‹ Download Task Definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > task-definition.json

    - name: ğŸ”„ Update Task Definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: automax-container
        image: ${{ needs.build.outputs.image-tag }}

    - name: ğŸš€ Deploy to Amazon ECS
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: âœ… Verify Deployment
      run: |
        # Wait for deployment to complete
        sleep 30
        
        # Get load balancer URL from Terraform output
        LB_URL=$(cd terraform && terraform output -raw load_balancer_dns)
        
        # Health check
        echo "Checking application health at: http://$LB_URL/health"
        curl -f "http://$LB_URL/health" || exit 1
        
        echo "ğŸ‰ Deployment successful!"
        echo "Application is available at: http://$LB_URL"

  # Job 5: Post-Deployment Notifications
  notify:
    name: ğŸ“¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: always()

    steps:
    - name: ğŸ“¢ Slack Notification - Success
      if: ${{ needs.deploy-application.result == 'success' }}
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'ğŸš— AutoMax Car Dealership deployed successfully!'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: ğŸ“¢ Slack Notification - Failure
      if: ${{ needs.deploy-application.result == 'failure' }}
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'âŒ AutoMax Car Dealership deployment failed!'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
